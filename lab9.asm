; =============================================
; ЛАБОРАТОРНАЯ РАБОТА №9
; Вычисление математических функций через ряды Тейлора
; ch(2x^3) = (e^(2x^3) + e^(-2x^3))/2
; =============================================
section .data
    ; Константы с плавающей точкой для вычислений
    x_start        dq 0.1      ; начальное значение x для таблицы
    x_end          dq 0.6      ; конечное значение x для таблицы
    step           dq 0.05     ; шаг изменения x в таблице
    two            dq 2.0      ; константа 2.0 для умножения
    one            dq 1.0      ; константа 1.0
    zero           dq 0.0      ; константа 0.0
    epsilon        dq 0.000001     ; точность вычислений для рядов Тейлора
    epsilon_high   dq 1e-12    ; высокая точность для ожидаемого значения
    three          dq 3.0      ; константа 3.0 для x^3
    five           dq 5.0      ; константа 5.0
    minus_one      dq -1.0     ; константа -1.0
    
    ; Строки форматов для функций ввода-вывода printf/scanf
    fmt_menu       db "=== ЛАБОРАТОРНАЯ РАБОТА №9 ===", 10
                   db "1 - Построить таблицу функции y = ch(2x^3)", 10
                   db "2 - Вычислить ln((1+x)/(1-x)) и сравнить", 10
                   db "0 - Выход", 10
                   db "Выберите действие (0-2): ", 0
    
    fmt_error      db "Ошибка: неверный ввод!", 10, 0
    fmt_exit       db "Программа завершена.", 10, 0
    fmt_input_x    db "Введите x (-1.0 < x < 1.0): ", 0
    fmt_invalid_x  db "Ошибка: x должен быть от -1.0 до 1.0 (не включая -1 и 1)!", 10, 0
    
    ; Заголовки и форматы вывода результатов
    fmt_header1    db "x        y = ch(2x^3)", 10, 0        ; заголовок таблицы
    fmt_header2    db 10, "Сравнение вычислений ln((1+x)/(1-x))", 10, 0
    fmt_table      db "%.2f    %.6f", 10, 0               ; формат строки таблицы
    fmt_result     db "Ряд Тейлора:  %.10f", 10           ; формат сравнения результатов
                   db "Ожидаемое:    %.10f", 10
                   db "Разница:      %.10f", 10, 0
    
    ; Форматы для ввода данных
    scan_int       db "%d", 0     ; формат для ввода целого числа
    scan_double    db "%lf", 0    ; формат для ввода числа с плавающей точкой

section .bss
    ; ==================================================
    ; Переменные для хранения промежуточных результатов
    ; ==================================================    
    choice         resd 1      ; переменная для выбора пользователя (4 байта)
    user_x         resq 1      ; переменная для x, введенного пользователем (8 байт)
    temp_x         resq 1      ; временная переменная для x в вычислениях
    temp_y         resq 1      ; временная переменная для y в вычислениях
    temp_result1   resq 1      ; результат вычисления рядом Тейлора
    temp_result2   resq 1      ; ожидаемый результат (для сравнения)
    temp_diff      resq 1      ; разница между вычисленным и ожидаемым результатом

section .text
extern printf, scanf  ; функции стандартной библиотеки C для ввода-вывода
global main

main:
    push rbp
    mov rbp, rsp
    
.menu_loop:
    ; ОТОБРАЖЕНИЕ МЕНЮ
    mov rdi, fmt_menu    ; первый аргумент printf - строка формата
    xor rax, rax         ; для variadic функций: 0 для целых, количество регистров XMM для дробных
    call printf          ; выводим меню на экран
    
    ; ЧТЕНИЕ ВЫБОРА ПОЛЬЗОВАТЕЛЯ
    mov rdi, scan_int    ; формат для ввода целого числа
    mov rsi, choice      ; указатель на переменную для сохранения результата
    xor rax, rax         ; 0 XMM регистров используется
    call scanf           ; читаем выбор пользователя
    
    ; Проверяем успешность ввода (scanf возвращает количество успешно прочитанных аргументов)
    cmp eax, 1
    jne .input_error     ; если ввод не удался, обрабатываем ошибку
    
    ; ОБРАБОТКА ВЫБОРА ПОЛЬЗОВАТЕЛЯ
    mov eax, [choice]    ; загружаем выбор пользователя
    cmp eax, 0
    je .exit             ; если 0 - выходим из программы
    cmp eax, 1
    je .task1            ; если 1 - задача 1 (таблица функции)
    cmp eax, 2
    je .task2            ; если 2 - задача 2 (вычисление логарифма)
    
    ; ОБРАБОТКА НЕВЕРНОГО ВВОДА
.input_error:
    mov rdi, fmt_error   ; сообщение об ошибке
    xor rax, rax
    call printf
    jmp .menu_loop       ; возвращаемся в меню

    ; ===================================================================================================================================================================
    ;                                                                     ПРЕД ОСНАВНАЯ ЧАСТЬ 
    ; ===================================================================================================================================================================
; вызываем функцию построения таблицы
.task1:
    call build_function_table  
    jmp .menu_loop

 ; вызываем функцию сравнения логарифма
.task2:
    call compare_logarithm
    jmp .menu_loop

    ; ЗАВЕРШЕНИЕ ПРОГРАММЫ
.exit:
    mov rdi, fmt_exit    ; сообщение о завершении
    xor rax, rax
    call printf
    
    pop rbp
    xor rax, rax         ; возвращаем 0 (успешное завершение)
    ret

; ======================================================================================================================================================================
;                                                                      ФУНКЦИЯ ДЛЯ ВЫЧИСЛЕНИЯ 2x^3
; ======================================================================================================================================================================
compute_2x3:
    push rbp
    mov rbp, rsp
    
    ; Вычисляем x^3
    movsd xmm1, xmm0     ; копируем x в xmm1
    mulsd xmm1, xmm0     ; x^2
    mulsd xmm1, xmm0     ; x^3
    
    ; Умножаем на 2
    mulsd xmm1, [two]    ; 2x^3
    movsd xmm0, xmm1     ; результат в xmm0
    
    pop rbp
    ret

; =================================================================
; Вычисляет y = ch(2x^3) для x в диапазоне [0.1, 0.6] с шагом 0.05
; =================================================================
build_function_table:
    push rbp
    mov rbp, rsp
    
    ; Выводим заголовок таблицы
    mov rdi, fmt_header1
    xor rax, rax
    call printf
    
    ; Инициализация начального значения x
    movsd xmm0, [x_start]
    movsd [temp_x], xmm0
    
.table_loop:
    ; ПРОВЕРКА УСЛОВИЯ ОКОНЧАНИЯ ЦИКЛА
    movsd xmm0, [temp_x]
    movsd xmm1, [x_end]
    comisd xmm0, xmm1        ; сравниваем x с конечным значением
    ja .table_done           ; если x > x_end, выходим из цикла
    
    ; ВЫЧИСЛЕНИЕ ЗНАЧЕНИЯ ФУНКЦИИ y = ch(2x^3)
    movsd xmm0, [temp_x]     ; загружаем текущее значение x
    call compute_2x3         ; вычисляем 2x^3
    call cosh_taylor         ; вычисляем ch(2x^3) через ряд Тейлора
    movsd [temp_y], xmm0     ; сохраняем результат
    
    ; ВЫВОД СТРОКИ ТАБЛИЦЫ
    mov rdi, fmt_table       ; формат вывода "x    y"
    movsd xmm0, [temp_x]     ; x
    movsd xmm1, [temp_y]     ; y
    mov rax, 2
    call printf
    
    ; =============================================
    ; ПЕРЕХОД К СЛЕДУЮЩЕМУ ЗНАЧЕНИЮ X
    ; =============================================
    movsd xmm0, [temp_x]
    addsd xmm0, [step]       ; увеличиваем x на шаг
    movsd [temp_x], xmm0
    jmp .table_loop          ; продолжаем цикл

.table_done:
    pop rbp
    ret

; =====================================================================================================================================================================
;                                                                        ЗАДАНИЕ №2
; =====================================================================================================================================================================
compare_logarithm:
    push rbp
    mov rbp, rsp
    
.get_input:
    ; ЗАПРОС ВВОДА X ОТ ПОЛЬЗОВАТЕЛЯ
    mov rdi, fmt_input_x
    xor rax, rax
    call printf
    
    ; Читаем значение x
    mov rdi, scan_double
    mov rsi, user_x
    xor rax, rax
    call scanf
    
    ; Проверяем успешность ввода
    cmp eax, 1
    jne .input_error
    
    ; ПРОВЕРКА ДИАПАЗОНА X: -1 < x < 1
    ; Проверка x >= 1
    movsd xmm0, [user_x]
    movsd xmm1, [one]
    comisd xmm0, xmm1
    jae .range_error         ; если x >= 1, ошибка диапазона
    
    ; Проверка x <= -1
    movsd xmm1, [minus_one]   ; -1.0
    comisd xmm0, xmm1
    jbe .range_error         ; если x <= -1, ошибка диапазона
    
    ; Проверка на -1 < x < 1 пройдена
    jmp .calculate
    
.input_error:
    mov rdi, fmt_error
    xor rax, rax
    call printf
    jmp .get_input           ; повторяем запрос ввода

.range_error:
    mov rdi, fmt_invalid_x
    xor rax, rax
    call printf
    jmp .get_input           ; повторяем запрос ввода

.calculate:
    ; ВЫВОД ЗАГОЛОВКА ДЛЯ СРАВНЕНИЯ
    mov rdi, fmt_header2
    xor rax, rax
    call printf
    
    ; ВЫЧИСЛЕНИЕ РЯДОМ ТЕЙЛОРА (с обычной точностью)
    movsd xmm0, [user_x]
    call ln_series_taylor    ; вычисляем ln((1+x)/(1-x)) моим методом
    movsd [temp_result1], xmm0 ; сохраняем результат
    
    ; ВЫЧИСЛЕНИЕ ОЖИДАЕМОГО ЗНАЧЕНИЯ (с высокой точностью)
    movsd xmm0, [user_x]
    call calculate_expected_ln ; вычисляем ожидаемое значение с высокой точностью
    movsd [temp_result2], xmm0 ; сохраняем результат
    
    ; ВЫЧИСЛЕНИЕ РАЗНИЦЫ МЕЖДУ РЕЗУЛЬТАТАМИ
    movsd xmm0, [temp_result1]
    subsd xmm0, [temp_result2] ; разность = ряд_Тейлора - ожидаемое
    movsd [temp_diff], xmm0
    
    ; ВЫВОД РЕЗУЛЬТАТОВ СРАВНЕНИЯ
    mov rdi, fmt_result
    movsd xmm0, [temp_result1]  ; результат ряда Тейлора
    movsd xmm1, [temp_result2]  ; ожидаемый результат
    movsd xmm2, [temp_diff]     ; разница
    mov rax, 3                  ; количество регистров XMM с дробными аргументами
    call printf
    
    pop rbp
    ret

; =======================================================
; ВЫЧИСЛЕНИЕ ГИПЕРБОЛИЧЕСКОГО КОСИНУСА ЧЕРЕЗ РЯД ТЕЙЛОРА
; ch(x) = 1 + x²/2! + x⁴/4! + x⁶/6! + ...
; Вход: xmm0 = x
; Выход: xmm0 = ch(x)
; =======================================================
cosh_taylor:
    push rbp
    mov rbp, rsp
    
    ; ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ ДЛЯ РЯДА
    movsd xmm1, [one]       ; сумма ряда (начинаем с 1)
    movsd xmm2, [one]       ; текущий член ряда (начинаем с 1 для первой итерации)
    movsd xmm3, xmm0        ; x
    movsd xmm4, xmm0        ; сохраняем x для возведения в степень
    mulsd xmm3, xmm4        ; x² (первая степень для вычислений)
    
    mov r8, 1               ; счетчик итераций
    mov r9, 2               ; текущий факториал в знаменателе (2! = 2)
    
cosh_loop:
    ; ВЫЧИСЛЕНИЕ ОЧЕРЕДНОГО ЧЛЕНА РЯДА
    movsd xmm2, xmm3        ; x^(2n)
    cvtsi2sd xmm5, r9       ; преобразуем факториал в double
    divsd xmm2, xmm5        ; делим x^(2n) на (2n)!
    
    ; ДОБАВЛЕНИЕ ЧЛЕНА К СУММЕ РЯДА
    addsd xmm1, xmm2        ; добавляем текущий член к сумме
    
    ; =============================================
    ; ПРОВЕРКА ТОЧНОСТИ
    ; =============================================
    movsd xmm5, [epsilon]   ; заданная точность
    comisd xmm2, xmm5       ; сравниваем текущий член с точностью
    jb cosh_end             ; если член меньше точности, выходим
    
    ; =============================================
    ; ПОДГОТОВКА СЛЕДУЮЩЕГО ЧЛЕНА РЯДА
    ; =============================================
    mulsd xmm3, xmm4        ; умножаем на x² для получения следующей степени
    mulsd xmm3, xmm4        ; x^(2n) * x² = x^(2n+2)
    
    ; =============================================
    ; ВЫЧИСЛЕНИЕ СЛЕДУЮЩЕГО ФАКТОРИАЛА
    ; =============================================
    inc r8                  ; увеличиваем счетчик
    mov rax, r9             ; текущий факториал
    add rax, 1              ; (2n+1)
    imul r9, rax            ; умножаем на (2n+1)
    add rax, 1              ; (2n+2)
    imul r9, rax            ; умножаем на (2n+2) - получаем (2n+2)!
    
    jmp cosh_loop           ; продолжаем цикл

cosh_end:
    movsd xmm0, xmm1        ; возвращаем сумму ряда
    pop rbp
    ret

; =============================================
; ВЫЧИСЛЕНИЕ LN((1+x)/(1-x)) ЧЕРЕЗ РЯД ТЕЙЛОРА
; ln((1+x)/(1-x)) = 2*(x + x³/3 + x⁵/5 + x⁷/7 + ...)
; Вход: xmm0 = x (|x| < 1)
; Выход: xmm0 = ln((1+x)/(1-x))
; =============================================
ln_series_taylor:
    push rbp
    mov rbp, rsp
    
    ; =============================================
    ; ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ ДЛЯ РЯДА
    ; =============================================
    movsd xmm1, xmm0        ; сохраняем x для возведения в степень
    movsd xmm2, xmm0        ; текущая степень x (начинаем с x¹)
    movsd xmm3, xmm0        ; сумма ряда (начинаем с x)
    
    ; Вычисляем x² для быстрого умножения
    movsd xmm4, xmm0
    mulsd xmm4, xmm0        ; x²
    
    mov r8, 3               ; текущий знаменатель (начинаем с 3)
    
ln_loop:
    ; =============================================
    ; ВЫЧИСЛЕНИЕ СЛЕДУЮЩЕЙ НЕЧЕТНОЙ СТЕПЕНИ X
    ; =============================================
    mulsd xmm2, xmm4        ; умножаем на x²: x^(2n-1) * x² = x^(2n+1)
    
    ; =============================================
    ; ВЫЧИСЛЕНИЕ ОЧЕРЕДНОГО ЧЛЕНА РЯДА
    ; =============================================
    cvtsi2sd xmm5, r8       ; преобразуем знаменатель в double
    movsd xmm6, xmm2        ; текущая степень x
    divsd xmm6, xmm5        ; делим x^(2n+1) на знаменатель
    
    ; =============================================
    ; ДОБАВЛЕНИЕ ЧЛЕНА К СУММЕ РЯДА
    ; =============================================
    addsd xmm3, xmm6        ; добавляем текущий член к сумме
    
    ; =============================================
    ; ПРОВЕРКА ТОЧНОСТИ (УСЛОВИЕ ВЫХОДА)
    ; =============================================
    ; Вычисляем абсолютное значение члена
    movsd xmm7, xmm6
    ; Если член отрицательный, меняем знак
    xorpd xmm8, xmm8        ; 0.0
    comisd xmm7, xmm8
    jae .positive
    ; Если отрицательный
    movsd xmm9, [minus_one]
    mulsd xmm7, xmm9        ; делаем положительным для сравнения
.positive:
    movsd xmm10, [epsilon]  ; заданная точность
    comisd xmm7, xmm10      ; сравниваем |член| с точностью
    jb ln_end               ; если член меньше точности, выходим
    
    ; =============================================
    ; ПОДГОТОВКА К СЛЕДУЮЩЕЙ ИТЕРАЦИИ
    ; =============================================
    add r8, 2               ; увеличиваем знаменатель на 2 (3, 5, 7, ...)
    jmp ln_loop             ; продолжаем цикл

ln_end:
    ; =============================================
    ; УМНОЖЕНИЕ СУММЫ НА 2 (ФОРМУЛА РЯДА)
    ; =============================================
    movsd xmm0, xmm3
    mulsd xmm0, [two]       ; умножаем сумму на 2
    
    pop rbp
    ret

; =============================================
; ВЫЧИСЛЕНИЕ ОЖИДАЕМОГО ЗНАЧЕНИЯ LN((1+x)/(1-x))
; Использует более высокую точность (1e-12)
; =============================================
calculate_expected_ln:
    push rbp
    mov rbp, rsp
    
    ; =============================================
    ; СОХРАНЕНИЕ ТЕКУЩЕГО EPSILON
    ; =============================================
    ; Выделяем место на стеке для сохранения epsilon
    sub rsp, 8
    movsd xmm0, [epsilon]
    movsd [rsp], xmm0
    
    ; =============================================
    ; УСТАНОВКА ВЫСОКОЙ ТОЧНОСТИ
    ; =============================================
    movsd xmm0, [epsilon_high]
    movsd [epsilon], xmm0
    
    ; =============================================
    ; ВЫЧИСЛЕНИЕ С ВЫСОКОЙ ТОЧНОСТЬЮ
    ; =============================================
    movsd xmm0, [user_x]
    call ln_series_taylor    ; вычисляем с высокой точностью
    
    ; =============================================
    ; ВОССТАНОВЛЕНИЕ EPSILON
    ; =============================================
    movsd xmm1, [rsp]
    movsd [epsilon], xmm1
    add rsp, 8
    
    ; Результат уже в xmm0
    pop rbp
    ret

; ============================================
; ПРИБЛИЖЕННОЕ ВЫЧИСЛЕНИЕ LN((1+x)/(1-x))
; Упрощенная версия с фиксированным количеством членов
; ln((1+x)/(1-x)) ≈ 2*(x + x³/3 + x⁵/5)
; =============================================
ln_series_taylor_approx:
    push rbp
    mov rbp, rsp
    
    movsd xmm1, xmm0        ; сохраняем x
    movsd xmm2, xmm0        ; сумма = x (первый член)
    
    ; =============================================
    ; ВЫЧИСЛЕНИЕ ВТОРОГО ЧЛЕНА: x³/3
    ; =============================================
    movsd xmm3, xmm0
    mulsd xmm3, xmm0        ; x²
    mulsd xmm3, xmm0        ; x³
    divsd xmm3, [three]     ; x³/3
    addsd xmm2, xmm3        ; добавляем к сумме
    
    ; =============================================
    ; ВЫЧИСЛЕНИЕ ТРЕТЬЕГО ЧЛЕНА: x⁵/5
    ; =============================================
    movsd xmm3, xmm0
    mulsd xmm3, xmm0        ; x²
    mulsd xmm3, xmm0        ; x³
    mulsd xmm3, xmm0        ; x⁴
    mulsd xmm3, xmm0        ; x⁵
    divsd xmm3, [five]      ; x⁵/5
    addsd xmm2, xmm3        ; добавляем к сумме
    
    ; =============================================
    ; УМНОЖЕНИЕ НА 2 (ПО ФОРМУЛЕ РЯДА)
    ; =============================================
    mulsd xmm2, [two]       ; 2*(x + x³/3 + x⁵/5)
    movsd xmm0, xmm2        ; возвращаем результат
    
    pop rbp
    ret